//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: MeaCov2C.cpp
//
// MATLAB Coder version            : 5.5
// C/C++ source code generated on  : 27-Feb-2024 15:53:12
//

// Include Files
#include "MeaCov2C.h"
#include "MeaCov2C_data.h"
#include "MeaCov2C_initialize.h"
#include "MeaCov2C_types.h"
#include "rt_nonfinite.h"
#include "rt_defines.h"
#include "rt_nonfinite.h"
#include <math.h>

// Function Declarations
static double rt_atan2d_snf(double u0, double u1);

static double rt_powd_snf(double u0, double u1);

// Function Definitions
//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_atan2d_snf(double u0, double u1)
{
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else if (rtIsInf(u0) && rtIsInf(u1)) {
    int i;
    int i1;
    if (u0 > 0.0) {
      i = 1;
    } else {
      i = -1;
    }
    if (u1 > 0.0) {
      i1 = 1;
    } else {
      i1 = -1;
    }
    y = atan2(static_cast<double>(i), static_cast<double>(i1));
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = atan2(u0, u1);
  }
  return y;
}

//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_powd_snf(double u0, double u1)
{
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    double d;
    double d1;
    d = fabs(u0);
    d1 = fabs(u1);
    if (rtIsInf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }
  return y;
}

//
// Arguments    : const double P[324]
//                const double V[4]
//                const double xtrue2err[342]
//                const struct0_T *AckermanBaseMea
//                double encoder_pri
//                double theta_num
//                const double Ackermanparam[8]
//                double sampling_time_ack
//                double R[36] // 輸出
// Return Type  : void
//
void MeaCov2C(const double P[324], const double V[4],
              const double xtrue2err[342], const struct0_T *AckermanBaseMea,
              double encoder_pri, double theta_num,
              const double Ackermanparam[8], double sampling_time_ack,
              double R[36])
{
  static const signed char b_a[114] = {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
      0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  double F[108];
  double b_F[108];
  double c_J[36];
  double J[12];
  double b_J[12];
  double L;
  double L1;
  double L2;
  double L3;
  double L4;
  double a;
  double delta_r_num;
  double l_ax;
  double l_rear;
  double r_wheel;
  int R_tmp;
  if (!isInitialized_MeaCov2C) {
    MeaCov2C_initialize();
  }
  delta_r_num = encoder_pri + AckermanBaseMea->steer;
  L = Ackermanparam[0] * 0.001;
  //  (m)
  L1 = Ackermanparam[1] * 0.001;
  L2 = Ackermanparam[2] * 0.001;
  L3 = Ackermanparam[3] * 0.001;
  L4 = Ackermanparam[4] * 0.001;
  l_rear = Ackermanparam[5] * 0.001;
  l_ax = Ackermanparam[6] * 0.001;
  r_wheel = Ackermanparam[7] * 0.001;
  //      sampling_time_ack = 0.01;
  a = rt_atan2d_snf(L, L1 / 2.0);
  if (delta_r_num == 0.0) {
    // Func_J_without_turn
    //     J = Func_J_without_turn(R_WHEEL,THETA)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     27-Feb-2024 14:07:20
    J[0] = 0.0;
    J[1] = 0.0;
    J[2] = 0.0;
    J[3] = 0.0;
    J[4] = 0.0;
    J[5] = 0.0;
    J[6] = r_wheel * cos(theta_num);
    J[7] = r_wheel * sin(theta_num);
    J[8] = 0.0;
    J[9] = 0.0;
    J[10] = 0.0;
    J[11] = 0.0;
  } else {
    double t13;
    double t15;
    double t16;
    double t19;
    double t2;
    double t24;
    double t29;
    double t3;
    double t30_tmp;
    double t31;
    double t35;
    double t38;
    double t4;
    double t40;
    double t41;
    double t43;
    double t5;
    double t6;
    double t71;
    double t72;
    double t78;
    double t79;
    double t8;
    double t84;
    double t9;
    // Func_J
    //     J =
    //     Func_J(L,L1,L2,L3,L4,A,DELTA_R,DELTA_T,L_AX,L_REAR,OMEGA_K,R_WHEEL,THETA)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     27-Feb-2024 14:03:21
    t2 = 1.0 / tan(delta_r_num);
    //  t3 = dirac(delta_r);
    //  t3 = callMyExternalFunction(delta_r);
    //  調整這個值以改變近似的精度和範圍
    t3 = exp(-(delta_r_num * delta_r_num) / 2.0E-6) / 0.002506628274631;
    if (rtIsNaN(delta_r_num)) {
      t4 = rtNaN;
    } else if (delta_r_num < 0.0) {
      t4 = -1.0;
    } else {
      t4 = (delta_r_num > 0.0);
    }
    t5 = cos(theta_num);
    t6 = sin(theta_num);
    delta_r_num += a;
    t8 = L1 * L1;
    t9 = L2 * L2;
    t19 = 1.0 / L2;
    L2 = l_rear / 2.0;
    t13 = t2 * t2;
    t15 = l_rear * t3;
    t16 = sin(delta_r_num);
    t24 = 1.0 / t4;
    t29 = t4 * L2;
    t30_tmp = L1 * L4;
    delta_r_num = t30_tmp * cos(delta_r_num) * 2.0;
    t31 = l_ax - L2;
    t35 = t8 * 2.0 - delta_r_num;
    delta_r_num = (t8 + L4 * L4) - delta_r_num;
    t38 = 1.0 / delta_r_num;
    L2 = 1.0 / sqrt(delta_r_num);
    t41 = (t9 - L3 * L3) + delta_r_num;
    t40 = rt_powd_snf(L2, 3.0);
    L3 = L4 * t16;
    t43 = L3 * L2;
    L2 = 1.0 / tan((-a + acos(1.0 / L1 * t35 * L2 / 2.0)) +
                   acos(t19 * L2 * t41 / 2.0));
    delta_r_num = l_rear - l_ax * 2.0;
    t71 = t2 + t31 * (t2 + L2) / delta_r_num;
    t72 = L * t4 * t71;
    L4 = L * t3 * t71 * 2.0;
    a = t29 - t72;
    t78 = 1.0 / (t29 + t72);
    t79 = t78 * t78;
    t84 = 1.0 / (a * t78 - 1.0);
    t31 = L * t4 *
          ((t13 +
            t31 *
                ((t13 -
                  (L2 * L2 + 1.0) *
                      (1.0 / sqrt(-(1.0 / t8 * (t35 * t35) * t38 / 4.0) + 1.0) *
                           (t43 - L3 * t35 * t40 / 2.0) +
                       1.0 / sqrt(-(1.0 / t9 * t38 * (t41 * t41) / 4.0) + 1.0) *
                           (L1 * t19 * t43 -
                            t30_tmp * t16 * t19 * t40 * t41 / 2.0))) +
                 1.0) /
                delta_r_num) +
           1.0);
    t35 = t84 * t84;
    L2 = sampling_time_ack * AckermanBaseMea->vel * r_wheel;
    l_rear = L2 * t24;
    l_ax = l_rear * t78;
    delta_r_num = l_ax * t84 * 2.0;
    t19 = cos(delta_r_num);
    t2 = sin(delta_r_num);
    t41 = (t15 + L4) - t31;
    delta_r_num = t2 * t2;
    t40 = t19 * 2.0;
    t29 = sampling_time_ack * r_wheel * t24 * t78 * t84;
    t38 = t29 * t19 * t2 * 4.0;
    t43 = t78 * ((t15 - L4) + t31) - a * t79 * t41;
    L4 = (L2 * t3 * (t24 * t24) * t78 * t84 * 4.0 +
          l_rear * t79 * t84 * t41 * 2.0) +
         l_ax * t35 * t43 * 2.0;
    a = 1.0 / sqrt(delta_r_num + (t40 + 2.0) * (t40 + 2.0) / 4.0);
    L2 = 1.0 / sqrt(delta_r_num + (t40 - 2.0) * (t40 - 2.0) / 4.0);
    l_rear = AckermanBaseMea->vel * r_wheel;
    l_ax = l_rear * t5;
    L3 = l_ax * t72;
    delta_r_num = L * AckermanBaseMea->vel * r_wheel * t3;
    J[0] = ((l_ax * t78 * t84 * t31 * 2.0 + L3 * t79 * t84 * t41 * 2.0) +
            L3 * t78 * t35 * t43 * 2.0) -
           delta_r_num * t5 * t71 * t78 * t84 * 4.0;
    l_ax = l_rear * t6;
    L3 = l_ax * t72;
    J[1] = ((l_ax * t78 * t84 * t31 * 2.0 + L3 * t79 * t84 * t41 * 2.0) +
            L3 * t78 * t35 * t43 * 2.0) -
           delta_r_num * t6 * t71 * t78 * t84 * 4.0;
    l_ax = t19 * t2 * L4 * 2.0;
    J[2] = a * (l_ax - t2 * (t40 + 2.0) * L4) * -0.25;
    J[3] = 0.0;
    J[4] = 0.0;
    J[5] = t3 / L2 - t4 * L2 * (l_ax - t2 * (t40 - 2.0) * L4) / 4.0;
    J[6] = r_wheel * t5 * t72 * t78 * t84 * -2.0;
    J[7] = r_wheel * t6 * t72 * t78 * t84 * -2.0;
    l_ax = t29 * t2;
    J[8] = a * (t38 - l_ax * (t40 + 2.0) * 2.0) / 4.0;
    J[9] = 0.0;
    J[10] = 0.0;
    J[11] = t4 * L2 * (t38 - l_ax * (t40 - 2.0) * 2.0) / 4.0;
  }
  if (rtIsNaN(J[5])) {
    J[5] = 0.0;
    //  如果 A 是 NaN，則將其設為 0
  }
  if (rtIsNaN(J[11])) {
    J[11] = 0.0;
    //  如果 A 是 NaN，則將其設為 0
  }
  for (int i = 0; i < 6; i++) {
    for (int i1 = 0; i1 < 18; i1++) {
      delta_r_num = 0.0;
      for (R_tmp = 0; R_tmp < 19; R_tmp++) {
        delta_r_num += static_cast<double>(b_a[i + 6 * R_tmp]) *
                       xtrue2err[R_tmp + 19 * i1];
      }
      F[i + 6 * i1] = delta_r_num;
    }
    for (int i1 = 0; i1 < 18; i1++) {
      delta_r_num = 0.0;
      for (R_tmp = 0; R_tmp < 18; R_tmp++) {
        delta_r_num += F[i + 6 * R_tmp] * P[R_tmp + 18 * i1];
      }
      b_F[i + 6 * i1] = delta_r_num;
    }
    delta_r_num = J[i + 6];
    L2 = J[i];
    b_J[i] = L2 * V[0] + delta_r_num * V[1];
    b_J[i + 6] = L2 * V[2] + delta_r_num * V[3];
  }
  for (int i = 0; i < 6; i++) {
    for (int i1 = 0; i1 < 6; i1++) {
      delta_r_num = 0.0;
      for (R_tmp = 0; R_tmp < 18; R_tmp++) {
        delta_r_num += b_F[i + 6 * R_tmp] * F[i1 + 6 * R_tmp];
      }
      R_tmp = i + 6 * i1;
      R[R_tmp] = delta_r_num;
      c_J[R_tmp] = b_J[i] * J[i1] + b_J[i + 6] * J[i1 + 6];
    }
  }
  for (int i = 0; i < 36; i++) {
    R[i] += c_J[i];
  }
}

//
// File trailer for MeaCov2C.cpp
//
// [EOF]
//
